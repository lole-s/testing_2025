### TDD (Test-Driven Development)

Ahora que sabemos m√°s sobre las pruebas unitarias, vamos a aprender una nueva forma de usarlas. Hasta ahora hemos escrito pruebas para verificar la funcionalidad del c√≥digo existente . A continuaci√≥n, vamos a utilizar pruebas para verificar la funcionalidad del c√≥digo que NO existe. Puede parecer extra√±o, pero este proceso tiene muchos beneficios, como veremos a continuaci√≥n.

Como su nombre indica, el desarrollo impulsado por pruebas (TDD, por sus siglas en ingl√©s) es un proceso de desarrollo de software en el que primero se escriben las pruebas unitarias. Sin embargo, eso no lo explica todo. Escribir primero las pruebas y pensar m√°s intencionalmente en el dise√±o del c√≥digo conduce a un mejor c√≥digo. El nombre proviene de la idea de que las pruebas impulsan el proceso de desarrollo.

Antes de poder comenzar a usar TDD, necesitamos una lista de caracter√≠sticas discretas que se puedan convertir en pruebas unitarias. Esto nos ayudar√° a mantener nuestras pruebas enfocadas en una funcionalidad espec√≠fica que deber√≠a generar un c√≥digo f√°cil de leer. A medida que vayamos agregando caracter√≠sticas, iremos ganando confianza.

#### Rojo, verde, refactorizaci√≥n 

Si bien el objetivo principal es agregar nuevas caracter√≠sticas y hacer que nuestro c√≥digo funcione, tambi√©n queremos escribir c√≥digo legible y eficiente que nos enorgullezca. El mantra rojo, verde y refactorizaci√≥n describe el proceso de escribir pruebas, ver que pasan y luego mejorar el c√≥digo. 

- Rojo -> Escribe una prueba fallida.
- Verde -> Hazlo pasar implementando el c√≥digo.
- Refactorizar -> Mejorar el c√≥digo.

<img src="..\img\TDD.png" alt="Ciclo TDD" width="300" height="200">


**Refactorizar c√≥digo** significa mantener la misma caracter√≠stica general, pero cambiar la forma en que se implementa esa caracter√≠stica. Dado que tenemos una prueba para verificar nuestro c√≥digo, podemos cambiar el c√≥digo con confianza, sabiendo que la prueba identificar√° inmediatamente cualquier error. A continuaci√≥n, se muestran algunos ejemplos de refactorizaci√≥n:

  1. Utilizando diferentes estructuras de datos,
  2. Reducir la cantidad de veces que es necesario recorrer una matriz,
  3. Convertir la l√≥gica duplicada en una funci√≥n para que pueda reutilizarse.

La refactorizaci√≥n tambi√©n se realiza en un proceso TDD:
  
  1. Decidir c√≥mo mejorar la implementaci√≥n de la funci√≥n,
  2. Cambie la prueba unitaria para utilizar esta nueva idea,
  3. Ejecute el c√≥digo para ver si la prueba falla.
  4. Refactorizar el c√≥digo para implementar la nueva idea,
  5. Finalmente, vea la prueba aprobada con el dise√±o refactorizado.
   
[TDD en Python](https://www.youtube.com/watch?v=eQ0GCFWtpqE)

### RESUMEN CICLO TDD

| Etapa           | Acci√≥n                                     | Resultado esperado        |
| --------------- | ------------------------------------------ | ------------------------- |
| üü• **Red**      | Escrib√≠s los tests antes del c√≥digo        | Fallan                    |
| üü© **Green**    | Implement√°s lo m√≠nimo necesario            | Pasan                     |
| üîµ **Refactor** | Mejor√°s el c√≥digo manteniendo tests verdes | C√≥digo limpio y confiable |




_____________________________
#### Ejemplo 1: TDD con Python y pytest
 
 - [N√∫meros primos](https://pruebat.org/SaberMas/MiClase/inicia/33363/abaa7617bb10cf86d0d968e8e8f86384/342571)
 - [Como saber si un numero es primo](https://pruebat.org/SaberMas/MiClase/inicia/33363/7c01b819106dd3279e560cafdd8f3997/342572)
  
Supongamos que se nos solicita escribir un m√≥dulo Python que verifique si un n√∫mero es primo.

Requisitos discretos

1. Entrada v√°lida: la funci√≥n debe aceptar solo enteros. En caso contrario, retornar False.  
2. Comprobaci√≥n de n√∫meros menores o iguales a 1: retornar False para n ‚â§ 1.  
3. Comprobaci√≥n de divisibilidad: si existe un divisor aparte de 1 y el propio n√∫mero, retornar False; en caso contrario retornar True.


##### Paso 1: Escribir una prueba (Rojo)

Crea un archivo tests/test_is_prime.py y agrega:

```python
from is_prime import is_prime

def test_non_number_inputs():
    assert is_prime('seven') is False
    assert is_prime(None) is False
    assert is_prime([2]) is False

def test_non_integer_numbers():
    assert is_prime(2.5) is False
    assert is_prime(3.1) is False

def test_numbers_leq_one():
    assert is_prime(0) is False
    assert is_prime(1) is False
    assert is_prime(-5) is False

def test_non_prime_numbers():
    assert is_prime(4) is False
    assert is_prime(6) is False
    assert is_prime(9) is False

def test_prime_numbers():
    assert is_prime(2) is True
    assert is_prime(3) is True
    assert is_prime(5) is True
    assert is_prime(7) is True
```

##### Paso 2: Escribir el c√≥digo m√≠nimo (Green)

Crea is_prime.py en la ra√≠z del proyecto con la implementaci√≥n m√≠nima:

```python
def is_prime(num):
    if not isinstance(num, int):
        return False
    if num <= 1:
        return False
    for i in range(2, num):
        if num % i == 0:
            return False
    return True
```
- NOTA: 
  Esta funci√≥n determina si el argumento `num` es un n√∫mero primo. Devuelve True si `num` es un n√∫mero primo (entero mayor que 1 con solo dos divisores: 1 y s√≠ mismo); en caso contrario devuelve False.

  - Pasos:
    1. Comprueba el tipo: si `num` no es una instancia de `int`, retorna False (filtra floats, strings, None, etc.).
    2. Si `num` ‚â§ 1, retorna False (0, 1 y negativos no son primos).
    3. Recorre todos los enteros `i` desde 2 hasta `num-1` y, si alguno divide exactamente a `num` (resto 0), retorna False.
    4. Si no encuentra divisores, retorna True (es primo).


- Ejecuta pytest (por ejemplo `pytest -q`) y verifica que las pruebas pasen.



##### Paso 3: Refactorizar (Refactor)

- Mejora recomendada: limitar la b√∫squeda de divisores hasta la ra√≠z cuadrada de `num` (O(sqrt(n)))
    - Mejora 1 ‚Äî Iterar hasta la ra√≠z cuadrada:
Si n tiene un divisor distinto de 1 y de s√≠ mismo, entonces existe un par de factores a¬∑b = n y al menos uno de ellos es ‚â§ sqrt(n). Por tanto no hace falta probar divisores mayores que sqrt(n): si no encuentras ninguno ‚â§ sqrt(n), no existe ning√∫n divisor en el resto del rango.
Mejorar eficiencia comprobando divisores solo hasta la ra√≠z cuadrada:

```python
import math

def is_prime(num):
    if not isinstance(num, int):
        return False
    if num <= 1:
        return False
    limit = int(math.sqrt(num)) + 1
    for i in range(2, limit):
        if num % i == 0:
            return False
    return True
```

Vuelve a ejecutar pytest para confirmar que todos los tests siguen pasando despu√©s de la refactorizaci√≥n.


##### Paso 4: Refactorizar (Refactor) -  Ejercicio

Mejora 2 ‚Äî Tratar pares por separado y saltar pares:

Comprueba el caso especial n == 2 (es primo) y rechaza inmediatamente los m√∫ltiplos de 2. Despu√©s itera solo por impares (paso 2). As√≠ eliminas la mitad de las comprobaciones innecesarias (todos los pares >2 no son primos), reduciendo a√∫n m√°s el trabajo efectivo a aproximadamente O(sqrt(n)/2) sin afectar la exactitud.

