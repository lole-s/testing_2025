### TDD (Test-Driven Development)

Ahora que sabemos más sobre las pruebas unitarias, vamos a aprender una nueva forma de usarlas. Hasta ahora hemos escrito pruebas para verificar la funcionalidad del código existente . A continuación, vamos a utilizar pruebas para verificar la funcionalidad del código que NO existe. Puede parecer extraño, pero este proceso tiene muchos beneficios, como veremos a continuación.

Como su nombre indica, el desarrollo impulsado por pruebas (TDD, por sus siglas en inglés) es un proceso de desarrollo de software en el que primero se escriben las pruebas unitarias. Sin embargo, eso no lo explica todo. Escribir primero las pruebas y pensar más intencionalmente en el diseño del código conduce a un mejor código. El nombre proviene de la idea de que las pruebas impulsan el proceso de desarrollo.

Antes de poder comenzar a usar TDD, necesitamos una lista de características discretas que se puedan convertir en pruebas unitarias. Esto nos ayudará a mantener nuestras pruebas enfocadas en una funcionalidad específica que debería generar un código fácil de leer. A medida que vayamos agregando características, iremos ganando confianza.

#### Rojo, verde, refactorización 

Si bien el objetivo principal es agregar nuevas características y hacer que nuestro código funcione, también queremos escribir código legible y eficiente que nos enorgullezca. El mantra rojo, verde y refactorización describe el proceso de escribir pruebas, ver que pasan y luego mejorar el código. 

- Rojo -> Escribe una prueba fallida.
- Verde -> Hazlo pasar implementando el código.
- Refactorizar -> Mejorar el código.

<img src="..\img\TDD.png" alt="Ciclo TDD" width="300" height="200">


**Refactorizar código** significa mantener la misma característica general, pero cambiar la forma en que se implementa esa característica. Dado que tenemos una prueba para verificar nuestro código, podemos cambiar el código con confianza, sabiendo que la prueba identificará inmediatamente cualquier error. A continuación, se muestran algunos ejemplos de refactorización:

  1. Utilizando diferentes estructuras de datos,
  2. Reducir la cantidad de veces que es necesario recorrer una matriz,
  3. Convertir la lógica duplicada en una función para que pueda reutilizarse.

La refactorización también se realiza en un proceso TDD:
  
  1. Decidir cómo mejorar la implementación de la función,
  2. Cambie la prueba unitaria para utilizar esta nueva idea,
  3. Ejecute el código para ver si la prueba falla.
  4. Refactorizar el código para implementar la nueva idea,
  5. Finalmente, vea la prueba aprobada con el diseño refactorizado.
   
[TDD en Python](https://www.youtube.com/watch?v=eQ0GCFWtpqE)
_____________________________
#### Ejemplo 1: TDD con Python y pytest
 
 - [Números primos](https://pruebat.org/SaberMas/MiClase/inicia/33363/abaa7617bb10cf86d0d968e8e8f86384/342571)
 - [Como saber si un numero es primo](https://pruebat.org/SaberMas/MiClase/inicia/33363/7c01b819106dd3279e560cafdd8f3997/342572)
  
Supongamos que se nos solicita escribir un módulo Python que verifique si un número es primo.

Requisitos discretos

1. Entrada válida: la función debe aceptar solo enteros. En caso contrario, retornar False.  
2. Comprobación de números menores o iguales a 1: retornar False para n ≤ 1.  
3. Comprobación de divisibilidad: si existe un divisor aparte de 1 y el propio número, retornar False; en caso contrario retornar True.


##### Paso 1: Escribir una prueba (Rojo)

Crea un archivo tests/test_is_prime.py y agrega:

```python
from is_prime import is_prime

def test_non_number_inputs():
    assert is_prime('seven') is False
    assert is_prime(None) is False
    assert is_prime([2]) is False

def test_non_integer_numbers():
    assert is_prime(2.5) is False
    assert is_prime(3.1) is False

def test_numbers_leq_one():
    assert is_prime(0) is False
    assert is_prime(1) is False
    assert is_prime(-5) is False

def test_non_prime_numbers():
    assert is_prime(4) is False
    assert is_prime(6) is False
    assert is_prime(9) is False

def test_prime_numbers():
    assert is_prime(2) is True
    assert is_prime(3) is True
    assert is_prime(5) is True
    assert is_prime(7) is True
```

##### Paso 2: Escribir el código mínimo (Green)

Crea is_prime.py en la raíz del proyecto con la implementación mínima:

```python
def is_prime(num):
    if not isinstance(num, int):
        return False
    if num <= 1:
        return False
    for i in range(2, num):
        if num % i == 0:
            return False
    return True
```
- NOTA: 
  Esta función determina si el argumento `num` es un número primo. Devuelve True si `num` es un número primo (entero mayor que 1 con solo dos divisores: 1 y sí mismo); en caso contrario devuelve False.

  - Pasos:
    1. Comprueba el tipo: si `num` no es una instancia de `int`, retorna False (filtra floats, strings, None, etc.).
    2. Si `num` ≤ 1, retorna False (0, 1 y negativos no son primos).
    3. Recorre todos los enteros `i` desde 2 hasta `num-1` y, si alguno divide exactamente a `num` (resto 0), retorna False.
    4. Si no encuentra divisores, retorna True (es primo).


- Ejecuta pytest (por ejemplo `pytest -q`) y verifica que las pruebas pasen.



##### Paso 3: Refactorizar (Refactor)

- Mejora recomendada: limitar la búsqueda de divisores hasta la raíz cuadrada de `num` (O(sqrt(n)))
    - Mejora 1 — Iterar hasta la raíz cuadrada:
Si n tiene un divisor distinto de 1 y de sí mismo, entonces existe un par de factores a·b = n y al menos uno de ellos es ≤ sqrt(n). Por tanto no hace falta probar divisores mayores que sqrt(n): si no encuentras ninguno ≤ sqrt(n), no existe ningún divisor en el resto del rango.
Mejorar eficiencia comprobando divisores solo hasta la raíz cuadrada:

```python
import math

def is_prime(num):
    if not isinstance(num, int):
        return False
    if num <= 1:
        return False
    limit = int(math.sqrt(num)) + 1
    for i in range(2, limit):
        if num % i == 0:
            return False
    return True
```

Vuelve a ejecutar pytest para confirmar que todos los tests siguen pasando después de la refactorización.


##### Paso 4: Refactorizar (Refactor) -  Ejercicio

Mejora 2 — Tratar pares por separado y saltar pares:

Comprueba el caso especial n == 2 (es primo) y rechaza inmediatamente los múltiplos de 2. Después itera solo por impares (paso 2). Así eliminas la mitad de las comprobaciones innecesarias (todos los pares >2 no son primos), reduciendo aún más el trabajo efectivo a aproximadamente O(sqrt(n)/2) sin afectar la exactitud.

